use std::{fmt, ops::{Add, Mul}};

#[derive(Debug, Clone, PartialEq)]
pub struct Matrix<T> {
    pub rows: usize,
    pub cols: usize,
    pub data: Vec<T>,
}

impl<T> Matrix<T> {
    pub fn new(rows: usize, cols: usize, data: Vec<T>) -> Self {
        assert_eq!(rows * cols, data.len());
        Matrix { rows, cols, data }
    }
    pub fn get(&self, row: usize, col: usize) -> Option<&T> {
        if row < self.rows && col < self.cols {
            Some(&self.data[row * self.cols + col])
        } else {
            None
        }
    }
    pub fn get_mut(&mut self, row: usize, col: usize) -> Option<&mut T> {
        if row < self.rows && col < self.cols {
            Some(&mut self.data[row * self.cols + col])
        } else {
            None
        }
    }
}

impl<T> Matrix<T>
where
    T: Mul<Output = T> + Add<Output = T> + Copy + Default,
{
    pub fn multiply(&self, other: &Matrix<T>) -> Matrix<T> {
        if self.cols != other.rows {
            panic!("Dimension mismatch");
        }

        let mut result_data = vec![T::default(); self.rows * other.cols];

        for i in 0..self.rows {
            for j in 0..other.cols {
                let mut sum = T::default();
                for k in 0..self.cols {
                    let a_val = self.data[i * self.cols + k];
                    let b_val = other.data[k * other.cols + j];
                    sum = sum + (a_val * b_val);
                }
                result_data[i * other.cols + j] = sum;
            }
        }

        Matrix::new(self.rows, other.cols, result_data)
    }
}

impl Matrix<f64> {
    pub fn identity(size: usize) -> Matrix<f64> {
        let mut data = vec![0.0; size * size];
        for i in 0..size {
            data[i * size + i] = 1.0;
        }
        Matrix::new(size, size, data)
    }

    pub fn inverse(&self) -> Matrix<f64> {
        if self.rows != self.cols {
            panic!("Matrix must be a square");
        }

        let n = self.rows;
        let mut augmented = self.clone();
        let mut result = Matrix::identity(n);

        //
        // Following Gaussian Elimination algorithm adapted from code generated by Gemini 3:
        //

        // Gaussian Elimination
        for i in 0..n {
            // A. Find Pivot: element at (i, i) must be non-zero
            let mut pivot = augmented.get(i, i).unwrap().clone();

            // If pivot is 0, try to swap with a lower row
            if pivot.abs() < 1e-10 {
                let mut swapped = false;
                for k in (i + 1)..n {
                    if augmented.get(k, i).unwrap().abs() > 1e-10 {
                        // Swap rows in both augmented and result matrix
                        for col in 0..n {
                            // Swap augmented
                            let temp = augmented.data[i * n + col];
                            augmented.data[i * n + col] = augmented.data[k * n + col];
                            augmented.data[k * n + col] = temp;

                            // Swap result (identity side)
                            let temp_res = result.data[i * n + col];
                            result.data[i * n + col] = result.data[k * n + col];
                            result.data[k * n + col] = temp_res;
                        }
                        pivot = augmented.data[i * n + i]; // Update pivot
                        swapped = true;
                        break;
                    }
                }
                if !swapped {
                    panic!("Matrix is singular (determinant is 0) and cannot be inverted.");
                }
            }

            // B. Normalize the pivot row (make the diagonal element 1)
            // Divide the current row by the pivot
            for j in 0..n {
                augmented.data[i * n + j] /= pivot;
                result.data[i * n + j] /= pivot;
            }

            // C. Eliminate other rows (make the column 0 for all other rows)
            for k in 0..n {
                if k != i {
                    let factor = augmented.data[k * n + i];
                    for j in 0..n {
                        augmented.data[k * n + j] -= factor * augmented.data[i * n + j];
                        result.data[k * n + j] -= factor * result.data[i * n + j];
                    }
                }
            }
        }

        result
    }
}

impl<T: fmt::Display> fmt::Display for Matrix<T> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        for i in 0..self.rows {
            write!(f, "[ ")?;
            for j in 0..self.cols {
                if let Some(val) = self.get(i, j) {
                    write!(f, "{:^8.3} ", val)?;
                }
            }
            write!(f, "]\n")?;
        }
        Ok(())
    }
}
